! (C) Copyright 1989- ECMWF.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!
MODULE PROENVHALO_MOD

CONTAINS
SUBROUTINE PROENVHALO_SCC (NINF, NSUP,                            &
&                      WVPRPT,                                &
&                      WVENVI,                                &
&                      WAVNUM_EXT, CGROUP_EXT, OMOSNH2KD_EXT, &
&                      DELLAM1_EXT, COSPHM1_EXT,              &
&                      DEPTH_EXT, U_EXT, V_EXT )

! ----------------------------------------------------------------------

!**** *PROENVHALO* - WAVE PROPGATION

!*    PURPOSE.
!     --------

!     PRODUCES ARRAYS WITH GRID POINTS VALUES AND THEIR HALO
!     FOR ENVIRONMENT VARIABLES FOR THE WAVE PROPGATION 

! -------------------------------------------------------------------

      USE PARKIND_WAVE, ONLY : JWIM, JWRB, JWRU

      USE YOWFRED  , ONLY : WVPRPT_LAND
      USE YOWGRID  , ONLY : NPROMA_WAM, NCHNK, KIJL4CHNK, IJFROMCHNK
      USE YOWPARAM , ONLY : NFRE     , NFRE_RED
      USE YOWSHAL  , ONLY : BATHYMAX
      USE YOWTEST  , ONLY : IU06
      USE YOMHOOK  , ONLY : LHOOK,   DR_HOOK, JPHOOK
      USE YOWDRVTYPE, ONLY: ENVIRONMENT, FREQUENCY
! Yangjinhui
      USE MPEXCHNG_MOD, ONLY: MPEXCHNG_SCC
      USE YOWFIELD_MOD, ONLY : FREQUENCY_FIELD, ENVIRONMENT_FIELD
! ----------------------------------------------------------------------

      IMPLICIT NONE


      INTEGER(KIND=JWIM), INTENT(IN) :: NINF, NSUP ! HALO EXTEND NINF to NSUP+1

      TYPE(FREQUENCY_FIELD), INTENT(INOUT) :: WVPRPT

      TYPE(ENVIRONMENT_FIELD), INTENT(INOUT) :: WVENVI

      REAL(KIND=JWRB), DIMENSION(NINF:NSUP+1, NFRE_RED), INTENT(OUT) :: WAVNUM_EXT  ! WAVE NUMBER
      REAL(KIND=JWRB), DIMENSION(NINF:NSUP+1, NFRE_RED), INTENT(OUT) :: CGROUP_EXT  ! GROUP VELOCITY
      REAL(KIND=JWRB), DIMENSION(NINF:NSUP+1, NFRE_RED), INTENT(OUT) :: OMOSNH2KD_EXT ! OMEGA / SINH(2KD)
      REAL(KIND=JWRB), DIMENSION(NINF:NSUP+1), INTENT(OUT) :: DELLAM1_EXT ! 1/DELLA
      REAL(KIND=JWRB), DIMENSION(NINF:NSUP+1), INTENT(OUT) :: COSPHM1_EXT ! 1/COSPH
      REAL(KIND=JWRB), DIMENSION(NINF:NSUP+1), INTENT(OUT) :: DEPTH_EXT ! WATER DEPTH
      REAL(KIND=JWRB), DIMENSION(NINF:NSUP+1), INTENT(OUT) :: U_EXT ! U-COMPONENT OF SURFACE CURRENT
      REAL(KIND=JWRB), DIMENSION(NINF:NSUP+1), INTENT(OUT) :: V_EXT ! V-COMPONENT OF SURFACE CURRENT


      INTEGER(KIND=JWIM) :: IJ, M
      INTEGER(KIND=JWIM) :: ICHNK, KIJS, KIJL, IJSB, IJLB

      REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
      
      !DEVICE POINTERS
      REAL(KIND=JWRB), POINTER, CONTIGUOUS :: WAVNUM_DPTR(:,:,:) => NULL()
      REAL(KIND=JWRB), POINTER, CONTIGUOUS :: CGROUP_DPTR(:,:,:) => NULL()
      REAL(KIND=JWRB), POINTER, CONTIGUOUS :: OMOSNH2KD_DPTR(:,:,:) => NULL()
      REAL(KIND=JWRB), POINTER, CONTIGUOUS :: DELLAM1_DPTR(:,:) => NULL()
      REAL(KIND=JWRB), POINTER, CONTIGUOUS :: COSPHM1_DPTR(:,:) => NULL()
      REAL(KIND=JWRB), POINTER, CONTIGUOUS :: DEPTH_DPTR(:,:) => NULL()
      REAL(KIND=JWRB), POINTER, CONTIGUOUS :: UCUR_DPTR(:,:) => NULL()
      REAL(KIND=JWRB), POINTER, CONTIGUOUS :: VCUR_DPTR(:,:) => NULL()
! ----------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('PROENVHALO_SCC',0,ZHOOK_HANDLE)
CALL WVPRPT%DEVICE_POINTER(WAVNUM=WAVNUM_DPTR,CGROUP=CGROUP_DPTR,OMOSNH2KD=OMOSNH2KD_DPTR)
CALL WVENVI%DEVICE_POINTER(DELLAM1=DELLAM1_DPTR,COSPHM1=COSPHM1_DPTR,&
&DEPTH=DEPTH_DPTR,UCUR=UCUR_DPTR,VCUR=VCUR_DPTR)

!!! mapping chuncks to block ONLY for actual grid points !!!!
!$acc  data present(IJFROMCHNK,KIJL4CHNK,IJFROMCHNK,WAVNUM_EXT,CGROUP_EXT,OMOSNH2KD_EXT,&
!$acc & DELLAM1_EXT,COSPHM1_EXT,DEPTH_EXT,U_EXT,V_EXT,WAVNUM_DPTR,CGROUP_DPTR,&
!$acc & OMOSNH2KD_DPTR,DELLAM1_DPTR,COSPHM1_DPTR,DEPTH_DPTR,UCUR_DPTR,VCUR_DPTR)
!$acc parallel loop
      DO ICHNK = 1, NCHNK
        KIJS = 1
        IJSB = IJFROMCHNK(KIJS, ICHNK)
        KIJL = KIJL4CHNK(ICHNK)
        IJLB = IJFROMCHNK(KIJL, ICHNK)

        WAVNUM_EXT(IJSB:IJLB, 1:NFRE_RED) = WAVNUM_DPTR(KIJS:KIJL, 1:NFRE_RED,ICHNK)
        CGROUP_EXT(IJSB:IJLB, 1:NFRE_RED) = CGROUP_DPTR(KIJS:KIJL, 1:NFRE_RED,ICHNK)
        OMOSNH2KD_EXT(IJSB:IJLB, 1:NFRE_RED) = OMOSNH2KD_DPTR(KIJS:KIJL, 1:NFRE_RED,ICHNK)

        DELLAM1_EXT(IJSB:IJLB) = DELLAM1_DPTR(KIJS:KIJL,ICHNK)
        COSPHM1_EXT(IJSB:IJLB) = COSPHM1_DPTR(KIJS:KIJL,ICHNK)
        DEPTH_EXT(IJSB:IJLB) = DEPTH_DPTR(KIJS:KIJL,ICHNK)
        U_EXT(IJSB:IJLB) = UCUR_DPTR(KIJS:KIJL,ICHNK)
        V_EXT(IJSB:IJLB) = VCUR_DPTR(KIJS:KIJL,ICHNK)
      ENDDO
!$acc end data
!!    should be combined into one single data exchange, when we start using this option.... !!!
      CALL MPEXCHNG_SCC(WAVNUM_EXT, NFRE_RED, 1, 1)
      CALL MPEXCHNG_SCC(CGROUP_EXT, NFRE_RED, 1, 1)
      CALL MPEXCHNG_SCC(OMOSNH2KD_EXT, NFRE_RED, 1, 1)
      CALL MPEXCHNG_SCC(COSPHM1_EXT, 1, 1, 1)
      CALL MPEXCHNG_SCC(DELLAM1_EXT, 1, 1, 1)
      CALL MPEXCHNG_SCC(DEPTH_EXT, 1, 1, 1)
      CALL MPEXCHNG_SCC(U_EXT, 1, 1, 1)
      CALL MPEXCHNG_SCC(V_EXT, 1, 1, 1)
      
!$acc kernels present(WAVNUM_EXT,CGROUP_EXT,OMOSNH2KD_EXT,DELLAM1_EXT,COSPHM1_EXT,&
!$acc & DEPTH_EXT,U_EXT,V_EXT) copyin(WVPRPT_LAND,WVPRPT_LAND%WAVNUM,WVPRPT_LAND%CGROUP,WVPRPT_LAND%OMOSNH2KD)
      WAVNUM_EXT(NSUP+1,1:NFRE_RED) = WVPRPT_LAND%WAVNUM(1:NFRE_RED)
      CGROUP_EXT(NSUP+1,1:NFRE_RED) =  WVPRPT_LAND%CGROUP(1:NFRE_RED)
      OMOSNH2KD_EXT(NSUP+1,1:NFRE_RED) = WVPRPT_LAND%OMOSNH2KD(1:NFRE_RED)
      DELLAM1_EXT(NSUP+1) = 0.0_JWRB 
      COSPHM1_EXT(NSUP+1) = 0.0_JWRB 
      DEPTH_EXT(NSUP+1) = BATHYMAX
      U_EXT(NSUP+1) = 0.0_JWRB
      V_EXT(NSUP+1) = 0.0_JWRB
!$acc end kernels
IF (LHOOK) CALL DR_HOOK('PROENVHALO_SCC',1,ZHOOK_HANDLE)

END SUBROUTINE PROENVHALO_SCC

END MODULE
