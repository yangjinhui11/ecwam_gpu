MODULE YOMOML


USE PARKIND1  ,ONLY : JPIM     ,JPRB

!--Dr.Hook references removed, because these locks may also be
!  called from within drhook.c itself !! 
!--Also, there could be considerable & unjustified overhead
!  when using Dr.Hook in such a low level
!**SS/18-Feb-2005

IMPLICIT NONE

SAVE

PRIVATE

PUBLIC OML_WAIT_EVENT, OML_SET_EVENT, OML_INCR_EVENT, &
   &   OML_MY_THREAD,  OML_MAX_THREADS , OML_OMP, &
   &   OML_IN_PARALLEL, OML_FUNCT, &
   &   OML_UNSET_LOCK, OML_INIT_LOCK, OML_SET_LOCK, OML_DESTROY_LOCK

INTEGER(KIND=JPIM) :: M_LOCK
INTEGER(KIND=JPIM) :: M_OML_LOCK


CONTAINS

FUNCTION OML_OMP()
LOGICAL :: OML_OMP
OML_OMP=.FALSE.
!$ OML_OMP=.TRUE.
END FUNCTION OML_OMP

FUNCTION OML_IN_PARALLEL()
LOGICAL :: OML_IN_PARALLEL
LOGICAL :: OMP_IN_PARALLEL
REAL(KIND=JPRB) :: ZHOOK_HANDLE
OML_IN_PARALLEL=.FALSE.
!$ OML_IN_PARALLEL=((OML_MAX_THREADS() > 1).AND.OMP_IN_PARALLEL())
END FUNCTION OML_IN_PARALLEL

FUNCTION OML_FUNCT(K,MYLOCK)
LOGICAL :: OML_FUNCT
INTEGER(KIND=JPIM) :: K,MYLOCK
IF(K.EQ.MYLOCK) THEN
 OML_FUNCT =.TRUE.
ELSE
 OML_FUNCT=.FALSE.
ENDIF
END FUNCTION OML_FUNCT

SUBROUTINE OML_UNSET_LOCK(MYLOCK)
INTEGER(KIND=JPIM),optional :: MYLOCK
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!$ IF(PRESENT(MYLOCK))THEN
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_UNSET_LOCK(MYLOCK)
!$   ENDIF
!$ ELSE
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_UNSET_LOCK(M_LOCK)
!$   ENDIF
!$ ENDIF
END SUBROUTINE OML_UNSET_LOCK

SUBROUTINE OML_SET_LOCK(MYLOCK)
INTEGER(KIND=JPIM),optional :: MYLOCK
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!$ IF(PRESENT(MYLOCK))THEN
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_SET_LOCK(MYLOCK)
!$   ENDIF
!$ ELSE
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_SET_LOCK(M_LOCK)
!$   ENDIF
!$ ENDIF
END SUBROUTINE OML_SET_LOCK

SUBROUTINE OML_INIT_LOCK(MYLOCK)
INTEGER(KIND=JPIM),optional :: MYLOCK
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!$ IF(PRESENT(MYLOCK))THEN
!$     CALL OMP_INIT_LOCK(MYLOCK)
!$ ELSE
!$     CALL OMP_INIT_LOCK(M_LOCK)
!$ ENDIF
END SUBROUTINE OML_INIT_LOCK

SUBROUTINE OML_DESTROY_LOCK(MYLOCK)
INTEGER(KIND=JPIM),optional :: MYLOCK
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!$ IF(PRESENT(MYLOCK))THEN
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_DESTROY_LOCK(MYLOCK)
!$   ENDIF
!$ ELSE
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_DESTROY_LOCK(M_LOCK)
!$   ENDIF
!$ ENDIF
END SUBROUTINE OML_DESTROY_LOCK

SUBROUTINE OML_WAIT_EVENT(K,MYLOCK)
INTEGER(KIND=JPIM) :: K
INTEGER(KIND=JPIM),OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  DO
    IF(OML_FUNCT(K,MYLOCK)) EXIT
  ENDDO
ELSE
  DO
    IF(OML_FUNCT(K,M_OML_LOCK)) EXIT
  ENDDO
ENDIF
END SUBROUTINE OML_WAIT_EVENT

SUBROUTINE OML_SET_EVENT(K,MYLOCK)
INTEGER(KIND=JPIM) :: K
INTEGER(KIND=JPIM),OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  MYLOCK=K
ELSE
  M_OML_LOCK=K
ENDIF
END SUBROUTINE OML_SET_EVENT

SUBROUTINE OML_INCR_EVENT(K,MYLOCK)
INTEGER(KIND=JPIM) :: K
INTEGER(KIND=JPIM),intent(inout),OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  MYLOCK=MYLOCK+K
ELSE
  M_OML_LOCK=M_OML_LOCK+K
ENDIF
END SUBROUTINE OML_INCR_EVENT

FUNCTION OML_MY_THREAD()
INTEGER(KIND=JPIM) :: OML_MY_THREAD
INTEGER(KIND=JPIM) OMP_GET_THREAD_NUM
OML_MY_THREAD = 1
!$ OML_MY_THREAD = OMP_GET_THREAD_NUM()+1
END FUNCTION OML_MY_THREAD

FUNCTION OML_MAX_THREADS()
INTEGER(KIND=JPIM) :: OML_MAX_THREADS
INTEGER(KIND=JPIM) OMP_GET_MAX_THREADS
OML_MAX_THREADS = 1
!$ OML_MAX_THREADS = OMP_GET_MAX_THREADS()
END FUNCTION OML_MAX_THREADS

END MODULE YOMOML
